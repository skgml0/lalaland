import sys
from sys import stdin, stdout
n= int(stdin.readline().rstrip())

#모든 범위를 포함하는 리스트 선언( 모든 값은 0으로 초기화)
count=[0] * (10001)
for i in range(n):
    input_num= int(stdin.readline().rstrip())
    count[input_num]+=1 #각 데이터에 해당하는 인덱스의 값 증가
for i in range(len(count)): #리스트에 기록된 정렬 정보 확인
    for j in range(count[i]):
        sys.stdout.write(str(i)+"\n")#띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력

"""계수 정렬의 시간 복잡도 
모든 데이터가 양의 정수인 상황에서 데이터의 개수를 n, 데이터 중 최대값의 크기를 k라고 할 때,
계수 정렬의 시간 복잡도는 O(n+k)이다. 계수 정렬은 앞에서부터 데이터를 하나씩 확인하면서 
리스트에서 적절한 인덱스의 값을 1씩 증가시킬 뿐만 아니라, 추후에 리스트의 각 인덱스에 해당하는 값들을
확인할 때 데이터 중 최댓값의 크기만큼 반복을 수행해야 하기 때문이다. 
따라서 데이터의 범위만 한정되어 있다면 효과적으로 사용할 수 있으며 항상 빠르게 동작한다.
사실상 현존하는 정렬 알고리즘 중에서 기수 정렬(radlix sort)과 더불어 가장 빠르다고 볼 수 있다.
보통 기수 정렬은 계수 정렬에 비해서 동작은 느리지만, 처리할 수 있는 정수의 크기는 더 크다. 
다만 알고리즘 원리나 소스코드는 더 복잡하다. 다행히 반드시 기수 정렬을 이용해야만 해결할 수 있는
문제는 코테에서 거의 출제되지 않으므로, 책에서는 기수정렬에 대해서 자세히 다루지는 않는다.
계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있다. 예를 들어 데이터가 0과 999,999 단 2개만
존재한다고 가정해보자. 이럴 때에도 리스트의 크기가 100만개가 되도록 선언해야 한다. 따라서 항상 사용할 
수 있는 정렬 알고리즘은 아니며 동일한 값을 가지는 데이터가 여러개 등장할 때 적합하다. 
예를 들어 성적의 경우 100점을 맞은 학생이 여러 명일 수 있기 때문에 계수 정렬이 효과적이다. 
반면에 앞서 설명한 퀵정렬은 일반적인 경우에서 평균적으로 빠르게 동작하기 때문에 데이터의 특성을 
파악하기 어렵다면 퀵 정렬을 이용하는 것이 유리하다.
다시 말해 계수 정렬은 데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을수록
유리하며 항상 사용할 수는 없다. 하지만 조건만 만족한다면 계수정렬은 정렬해야 하는 데이터의 개수가
매우 많을 때에도 효과적으로 사용할 수 있다. 다만 일반적인 코테 시스템 환경에서는 메모리 공간상
제약과 입출력 시간 문제로 인하여 입력되는 데이터의 개수를 1000만개 이상으로 설정할 수 없는 
경우가 많기 때문에, 정렬 문제에서의 데이터 개수는 1000만개 미만으로 출제될 것이다. 
계수 정렬의 공간 복잡도는 O(n+k)이다."""